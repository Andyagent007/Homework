<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scip1</title>
    <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-okaidia.css" rel="stylesheet" />
    <style>
      .title
      {
        text-align: center;
        font-family: monospace;
        color: #E3DFFF;
      }
      .description{
        font-size: large;
        font-weight: bold;
        font-family: monospace;
        color: #AB8975;
      }
      .exercises
      {
        display: flex;
        flex-direction: column;
        font-family: monospace;
        color: #BFB5B3;
      }
      .exercise
      {
        font-weight: bold;
        font-size: larger;
      }
      .exercise-coded-block{
        background-color: #352a3c;
        border: 1px solid #675275;
        overflow: hidden;
        margin-top: 10px;
        margin-bottom: 10px;
        margin-right: 15px;
        padding: 5px;
        border-radius: 10px;
      }
      .exercise-coded{
        background-color: #4f4b5d;
        color: #d8d6d3;
        padding: 2px 5px;
        border-radius: 3px;
        font-weight: normal;
        font-size: 90%;
      }
      .answer-coded{
        background-color: #4f4b5d;
        color: #E1FEFF;
        padding: 2px 5px;
        border-radius: 3px;
        font-weight: normal;
        font-size: 90%;
      }
      .links
      {
        color: #E3D0DD;
        text-decoration: none;
      }
      .answer-block
      {
        background-color: #231123;
        display: flex;
        flex-direction: column;
        padding: 10px;
        padding-bottom: 20px;
        border-radius: 5px;
      }
      .answer-header
      {
        padding-left: 5px;
        color: #a2a2f1;
        text-shadow: 
         0 0 10px #52528C,
         0 0 20px #6B6BA6
        ;
      }
      .answer-content
      {
        padding-left: 15px;
        color: #7C9EB2;
        font-size: 15px;
        
      }
      .snippet-code{
        background-color: #352a3c;
        border: 1px solid #675275;
        overflow: hidden;
        margin-top: 10px;
        margin-bottom: 10px;
        margin-right: 15px;
        padding: 5px;
        border-radius: 10px;
      }
      .snippet-code-header{
        color: #616e75;
        font-size: 10px;
        padding: 5px;
      }
      pre.snippet-code-text{
        background-color: #352a3c;
        padding-top: 0%;
        padding-bottom: 0%;
        font-size: 13px;
        /* display: flex; */
        /* color: #7C9EB2; */
        /* overflow-x: auto; */
        
      }
      code.language-lisp{
        font-family:monospace;
        color: #fbe5fb;
      }
      .img-container{
        display: flex;
        flex-direction: column;
        width: 800px;
        height: 100px;
        justify-content: space-around;
        align-items: center;
        align-content: center;
        margin: 10px;
        padding: 10px;
        font-size: 15px;
        font-weight: bold;
        background-color:#3D3A4B;
        color: #BFB5B3;
        border-radius: 5px;
      }
    </style>
  </head>
<body bgcolor="#3D3A4B">
  <script src='https://cdn.jsdelivr.net/npm/prismjs/prism.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/prismjs/components/prism-lisp.min.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/prismjs/components/prism-javascript.min.js'></script>
  <h1 class="title">Lisp, the forgotten programming language for AIs</h1>
  <p class="description">
    The <a class="links" href="https://web.mit.edu/6.001/6.037/sicp.pdf"> 
    Structure and Interpretation of Computer Programs (SICP) </a> often called
    the "wizard book", teaches the core principles of programing
    using Scheme, a dialect of Lisp. Lisp is a programming language that was
    used back in the day to support such an important area of computer science,
    Artificial Intelligence.
    </p>
    <div class="exercises">
    <h2>
      Questions from Chapter 1:
    </h2>
    <ol>
      <li>
        <p class='exercise'>
          Exercise 1.3: Define a <span class='exercise-coded'>procedure</span>
          that takes three numbers as arguments and returns the sum of the
          squares of the two larger numbers.
        </p>
        <div class="answer-block">
          <h2 class="answer-header">ANSWER</h2>
          <div class="answer-content">
            When first attempting to solve this exercise, all the logic was 
            being held into one <span class='answer-coded'>procedure</span>. It
            looked like this:
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(define (add_larger_sqrs a b c)
  (if (> a b)
      (if (> b c) (sum-of-squares a b)
          (sum-of-squares a c)
      )
  (if (> a c) (sum-of-squares b a)
      (sum-of-squares b c))
  )
)
              </code></pre>
            </div>
            After analyzing the code, I realized I was using 4 times the 
            <span class='answer-coded'>sum-of-squares</span> function.
            Therefore, it was too repetitive, and the intent of it was obscured
            by the nested <span class="answer-coded">if</span> statements. Here
            is a re-factoring that more clearly expresses the goal of the code.
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-lisp">
  (define (two_largest_numbers a b c)
  (if (> a b)
    (if (> b c) (list a b)
      (list a c)
    )  
    (if (> c a) (list b c)
        (list a b)
  )  
  ))
  (define (add_largest_sqrs a b c)
  (apply sum-of-squares (two_largest_numbers a b c)))
              </code></pre>
            </div>
          </div>
        </div>
      </li>
      <li>
        <p class="exercise"> Exercise 1.4: Observe that our model of evaluation 
          allows for combinations whose operators are <span class=
          'exercise-coded'>compound expressions</span>. Use this
          observation to describe the behavior of the following 
          <span class='exercise-coded'>procedure:</span>
          <div class="snippet-code">
            <div class="snippet-code-header">Scheme</div>
            <pre class="snippet-code-text"><code class="language-lisp">
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
            </code></pre>
          </div>
        </p>
        <div class="answer-block">
          <h2 class="answer-header">ANSWER</h2>
          <div class="answer-content">
            In order to analyze the behavior of: 
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
              </code></pre>
            </div>
            Consider a simpler example: 
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(define (a-plus-b a b)
    (+ a b))
              </code></pre>
            </div>
            The <span class='answer-coded'>+</span> operation is clearly
            visible; the point of the exercise is to observe that in the 
            <span class='answer-coded'>a-plus-abs-b</span> procedure
            (a.k.a. function) the actual operation performed is not a simple 
            <span class="answer-coded">+</span> or <span class='answer-coded'>
            -</span>, but is something determined by the compound expresion
            <span class='answer-coded'>(if (> b 0) + -)</span>. 
          </div>
      </li>
      <li>
        <p class="exercise"> 
          Exercise 1.5: Ben Bitdiddle has invented a test to 
          determine whether the interpreter he is faced with is using
          <span class='exercise-coded'>applicative-order</span>
          evaluation or <span class='exercise-coded'>normal-order</span>
          evaluation. He defines the following two procedures:
          <div class="snippet-code">
            <div class="snippet-code-header">Scheme</div>
            <pre class="snippet-code-text"><code class="language-lisp">
(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y))
            </code></pre>
          </div>
        </p>
        <p class="exercise">
          Then he evaluates the expression:
          <div class="snippet-code">
            <div class="snippet-code-header">Scheme</div>
            <pre class="snippet-code-text"><code class="language-lisp">
(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y))
            </code></pre>
          </div>
        </p>
        <p class="exercise">
          What behavior will Ben observe with an interpreter that uses
          <span class='exercise-coded'>applicative-order</span> evaluation? What
          behavior will he observe with an interpreter that uses
          <span class='exercise-coded'>normal-order evaluation?</span> Explain
          your answer. (Assume that the evaluation rule for the special form 
          <span class='exercise-coded'>if</span> is the same whether the
          interpreter is using normal or applicative order: The predicate
          expression is evaluated first, and the result determines whether to
          evaluate the consequent or the alternative expression.)
        </p>
        <div class="answer-block">
          <h2 class="answer-header">ANSWER</h2>
          <div class="answer-content">
            In order to solve this exercise we analyze how the procedure would 
            be intrepreted using <span class='exercise-coded'>
            normal-order evaluation</span><span style="font-weight: bold;">(note
            this just an interpretation of the steps of the normal-order
            evaluation for a real scheme program)</span>:
            <div class="snippet-code">
              <div class="snippet-code-header">normal-order evaluation</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(test 0 (p))
  (if (= 0 0) 0 (p))
        0
              </code></pre>
            </div>
            <p>
              As we see in the example above, the <span class='answer-coded'>
              normal-order </span> evaluation doesn't care for the value of p.
              It just gives the answer of 0. However, let's now do the <span 
              class='answer-coded'>applicative-order</span> evaluation for this
              expresion.
            </p>
            <div class="snippet-code">
              <div class="snippet-code-header">applicative-order evaluation</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(test 0 (p))
∞
              </code></pre>
            </div>
            <div style="display: flex; flex-direction: row;">
              <p>
                When running this command, it will cause an infinite loop. At
                the right is shown what it looks like at the bottom of the
                screen when I run the code using DrRacket.
              </p>
              <div class="img-container">
                DrRacket's bottom of the screen overview
                <img style="width:80%;" src="y.webp">
              </div>
          </div>
          </div>
        </div>
      </li>
      <li>
        <p class="exercise">
          Exercise 1.6: Alyssa P. Hacker doesn’t see why <span 
          class='exercise-coded'>if</span> needs to be provided as a 
          <span class='exercise-coded'>special form</span>. “Why can’t I just
          define it as an ordinary procedure in terms of <span 
          class='exercise-coded'>cond</span>?” she asks. Alyssa’s friend Eva Lu
          Ator claims this can indeed be done, and she defines a new version of
          if:
          <div class="snippet-code">
            <div class="snippet-code-header">Scheme</div>
            <pre class="snippet-code-text"><code class="language-lisp">
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
            </code></pre>
          </div>
        </p>
        <p class="exercise">
          Eva demonstrates the program for Alyssa:
        </p>
        <div class="snippet-code">
            <div class="snippet-code-header">Scheme (demonstration of the program)</div>
            <pre class="snippet-code-text"><code class="language-lisp">
(new-if (= 2 3) 0 5)
5
(new-if (= 1 1) 0 5)
0
            </code></pre>
          </div>
        <p class="exercise">
          Delighted, Alyssa uses <span class='exercise-coded'>new-if</span> to
          rewrite the square-root program:
        </p>
        <div class="snippet-code">
            <div class="snippet-code-header">Scheme</div>
            <pre class="snippet-code-text"><code class="language-lisp">
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
            </code></pre>
          </div>
        <p class="exercise">
          What happens when Alyssa attempts to use this to compute
          square roots? Explain.
        </p>
        <div class="answer-block">
          <h2 class="answer-header">ANSWER</h2>
          <div class="answer-content">
            This version of square root with the <span 
            class='answer-coded'>new-if</span> procedure instead of
            using the special form <span class='answer-coded'>if</span>, would
            still be as accurate as the first version. However, it is going to
            be slower, than the one that uses the directly the <span
            class='answer-coded'>if</span>, because a special form only analyze
            the alternative of the predicate, <span style="font-weight:
            bold;">if</span> only the predicate is <span class='answer-coded'>
            FALSE</span>. On the other hand a procedure will (no matter what)
            analyze all the operands, this resulting in a much slower program.
          </div>
          <!-- <img src="Newtons_Method.png"> -->
        </div>
      </li>
      <li>
        <p class="exercise">
          Exercise 1.7:
        </p>
        <ol>
          <li>
            <p class="exercise">
              Exercise 1.7.1: The <span class='exercise-coded'>
              good-enough?</span> test used in computing square roots will not
              be very eﬀective for finding the square roots of very small
              numbers. Also, in real computers, arith-metic operations are
              almost always performed with limited precision. This makes our
              test inadequate for very large numbers. Explain these statements,
              with examples showing how the test fails for small and large
              numbers.
            </p>
            <div class="answer-block">
              <h2 class="answer-header">ANSWER</h2>
              <div class="answer-content">
                <h3>
                  The good-enough? test is not effective for finding square
                  roots of very small numbers:
                </h3>
                <p style="padding-left: 10px; padding-right: 5px;">
                  This statement is the easy one to perceive at first glance.
                  The issue with the <span class='answer-coded'>
                  good-enough?</span> procedure is that it compares the absolute
                  difference of the guess, and the x value, against a specific
                  quantity such as <span class='answer-coded'>0.001</span>.
                  Thus, when it receives as input a number that is smaller than
                  that quantity, at a certain point the guess will be enough to
                  satisfy the condition when the arithmetic is done in the <span
                  class='answer-coded'>good-enough?</span> procedure. However,
                  it will be far away to the real square root. For example,
                  let's take the number <span class=
                  'answer-coded'>0.000000000009</span>. The real square root of
                  this number is <span class='answer-coded'>0.000003</span>, but
                  this square-root program returns the value of <span
                  class='answer-coded'>0.03125000009590625</span>. What ended up
                  happening, is that the <span class='code'>improve</span>
                  procedure started to give the following numbers as the guess
                  through every iteration: 0.5000000000045, 0.25000000001125,
                  0.125000000023625, 0.06250000004781249, and the last,
                  0.03125000009590625. Now, why is this the last? It is because
                  of the following calculation in the <span class='
                  answer-coded'>good-enough?</span> procedure: 
                  <span class='answer-coded'>
                  (< (abs (- (square guess) x)) 0.001)</span>. Therefore, this
                  occur:
                  </p>
                  <div class="snippet-code">
                    <div class="snippet-code-header">normal-order
                      evaluation</div>
                    <pre class="snippet-code-text"><code class="language-lisp">
(< (abs (- (square 0.03125000009590625) 0.000000000009)) 0.001)
(< (abs (- (* 0.03125000009590625 0.03125000009590625) 0.000000000009)) 0.001)
(< (abs (- 0.0009765625059941405 0.000000000009)) 0.001)
#t
                    </code></pre>
                  </div>
                  <p style="padding-left: 10px; padding-right: 5px;">
                    Which the result is true, thus the number <span
                    class='answer-coded'>03125000009590625</span> according to
                    this algorithm is the square root of 0.000000000009.
                    Nonetheless, as mentioned before the real square root is
                    <span class='answer-coded'>0.000003</span>. This example
                    crearly shows the fauls of this algorithm for really small
                    numbers, but in a more clear way to say it, this algorithm
                    will not work for numbers that are smallers than the fixed
                    number in the <span class="answer-coded">good-enough?</span>
                    procedure.
                  </p>
                <h3>
                  In real computers arithmetics operations are almost always
                  performed with limited precision, making the test poor for
                  calculating large numbers.
                </h3>
                <p style="padding-left: 10px; padding-right: 5px;">
                  This problem is related to floating-point precision. As 
                  mentioned before, in computers huge numbers are not affected
                  by smaller numbers at a certain distance. Consider this
                  example, try this in your browser console:
                </p>
                <div class="snippet-code">
                  <div class="snippet-code-header">javascript</div>
                  <pre class="snippet-code-text"><code 
                    class="language-javascript">
let googol = 1e100
googol == googol + 1
                  </code></pre>
                </div> 
                <div style="display: flex; flex-direction: column; padding-left: 10px; padding-right: 5px;">
                  <p>
                    This should return something like this:
                  </p>
                  <img style="width: 30%; border-radius: 8px;" src="./googol_example.png"
alt="example_of_floating_point_precision_from_the_console">
                  <p>
                    So, according to that, we can now state that floating-point
                    numbers deals arithmetics with their own rules. Another
                    example could be with the number <span class="answer-coded">
                    1e49</span>. If we do the following code in <span 
                    class='answer-coded'>javascript</span>:
                  </p>
                    <div class="snippet-code">
                      <div class="snippet-code-header">javascript</div>
                      <pre class="snippet-code-text"><code 
                        class="language-javascript">
let exactSqrt = Math.sqrt(1e49) // this returns 3.162277660168379e+24
exactSqrt * exactSqrt // the value returned is 9.999999999999998e+48
                      </code></pre>
                    </div>
                    <p>
                      This is important to understand better floating-point
                      precision. As we can notice, the square root of <span
                      class='answer-coded'>1e49</span> is 3.162277660168379e+24;
                      however, this number squared does not give the exact same
                      value, as if we were working with a small number. This leads
                      us to the <span class='answer-coded'>good-enough?</span>
                      procedure. Same as the last time, lets analyze this example.
                      Supose that we iterate until we get this number <span
                      class='answer-coded'>3.162308428500741e+24</span> as our
                      guess. What will happen next is something like this:
                    </p>
                    <div class="snippet-code">
                      <div class="snippet-code-header">normal-order
                        evaluation</div>
                      <pre class="snippet-code-text"><code 
                        class="language-lisp">
(< (abs (- (square guess) x)) 0.001)
(< (abs (- (square 3.162308428500741e+24) 1e49)) 0.001)
(< (abs (- (* 3.162308428500741e+24 3.162308428500741e+24) 1e49)) 0.001)
(< (abs (- 1.0000194596966827e+49 1e49)) 0.001)
#f
                      </code></pre>
                    </div>
                    <p>
                      Why does it return false? Although the numbers looks
                      really close, they are actually not. They are different
                      for a large chain of numbers. We have to remember that
                      these are floating-point numbers, and they represent a
                      large sequence of numbers not just the ones that are
                      written down. Therefore, what will happen after it, is
                      that procedures like <span 
                      class="answer-coded">improve</span> and <span
                      class='answer-coded'>average</span>, they are really not
                      going to change the number at all anymore, because of
                      floating-point arithmetic. This ending in an infinite loop
                      or in an infinite call of functions, what will exceed at
                      some point the maximun call stack.
                    </p>
                  </p>
                </div>
              </div>
            </div>
          </li>
          <li>
            <p class="exercise">
              Exercise 1.7.2: An alterna-tive strategy for implementing 
              good-enough? is to watch how guess changes from one iteration to 
              the next and to stop when the change is a very small fraction of 
              the guess. Design a square-root procedure that uses this kind of
              end test. Does this work better for small and large numbers?
            </p>
            <div class="answer-block">
              <h2 class="answer-header">ANSWER</h2>
              <div class="answer-content">
                
              </div>
            </div>
          </li>
        </ol>
      </li>
    </ol>
  </div>
</body>
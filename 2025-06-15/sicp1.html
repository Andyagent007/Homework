<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scip1</title>
    <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-okaidia.css" rel="stylesheet" />
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <style>
      .title
      {
        text-align: center;
        font-family: monospace;
        color: #E3DFFF;
      }
      .description{
        font-size: large;
        font-weight: bold;
        font-family: monospace;
        color: #AB8975;
      }
      .exercises
      {
        display: flex;
        flex-direction: column;
        font-family: monospace;
        color: #BFB5B3;
      }
      .exercise
      {
        font-weight: bold;
        font-size: larger;
      }
      .exercise-coded-block{
        background-color: #352a3c;
        border: 1px solid #675275;
        overflow: hidden;
        margin-top: 10px;
        margin-bottom: 10px;
        margin-right: 15px;
        padding: 5px;
        border-radius: 10px;
      }
      .exercise-coded{
        background-color: #4f4b5d;
        color: #d8d6d3;
        padding: 2px 5px;
        border-radius: 3px;
        font-weight: normal;
        font-size: 90%;
      }
      .answer-coded{
        background-color: #4f4b5d;
        color: #E1FEFF;
        padding: 2px 5px;
        border-radius: 3px;
        font-weight: normal;
        font-size: 90%;
      }
      .links
      {
        color: #E3D0DD;
        text-decoration: none;
      }
      .answer-block
      {
        background-color: #231123;
        display: flex;
        flex-direction: column;
        padding: 10px;
        padding-bottom: 20px;
        border-radius: 5px;
      }
      .answer-header
      {
        padding-left: 5px;
        color: #a2a2f1;
        text-shadow: 
         0 0 10px #52528C,
         0 0 20px #6B6BA6
        ;
      }
      .answer-content
      {
        padding-left: 15px;
        color: #7C9EB2;
        font-size: 15px;
        
      }
      .snippet-code{
        background-color: #352a3c;
        border: 1px solid #675275;
        overflow: hidden;
        margin-top: 10px;
        margin-bottom: 10px;
        margin-right: 15px;
        padding: 5px;
        border-radius: 10px;
      }
      .snippet-code-header{
        color: #616e75;
        font-size: 10px;
        padding: 5px;
      }
      pre.snippet-code-text{
        background-color: #352a3c;
        padding-top: 0%;
        padding-bottom: 0%;
        font-size: 13px;
        /* display: flex; */
        /* color: #7C9EB2; */
        /* overflow-x: auto; */
        
      }
      code.language-lisp{
        font-family:monospace;
        color: #fbe5fb;
      }
      .img-container{
        display: flex;
        flex-direction: column;
        width: 800px;
        height: 100px;
        justify-content: space-around;
        align-items: center;
        align-content: center;
        margin: 10px;
        padding: 10px;
        font-size: 15px;
        font-weight: bold;
        background-color:#3D3A4B;
        color: #BFB5B3;
        border-radius: 5px;
      }
    </style>
  </head>
<body bgcolor="#3D3A4B">
  <script src='https://cdn.jsdelivr.net/npm/prismjs/prism.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/prismjs/components/prism-lisp.min.js'></script>
  <script src='https://cdn.jsdelivr.net/npm/prismjs/components/prism-javascript.min.js'></script>
  
  <h1 class="title">Lisp, the forgotten programming language for AIs</h1>
  <p class="description">
    The <a class="links" href="https://web.mit.edu/6.001/6.037/sicp.pdf"> 
    Structure and Interpretation of Computer Programs (SICP) </a> often called
    the "wizard book", teaches the core principles of programing
    using Scheme, a dialect of Lisp. Lisp is a programming language that was
    used back in the day to support such an important area of computer science,
    Artificial Intelligence.
    </p>
    <div class="exercises">
    <h2>
      Questions from Chapter 1:
    </h2>
    <ol>
      <li>
        <p class='exercise'>
          Exercise 1.3: Define a <span class='exercise-coded'>procedure</span>
          that takes three numbers as arguments and returns the sum of the
          squares of the two larger numbers.
        </p>
        <div class="answer-block">
          <h2 class="answer-header">ANSWER</h2>
          <div class="answer-content">
            When first attempting to solve this exercise, all the logic was 
            being held into one <span class='answer-coded'>procedure</span>. It
            looked like this:
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-scheme">
(define (add_larger_sqrs a b c)
  (if (> a b)
      (if (> b c) (sum-of-squares a b)
          (sum-of-squares a c)
      )
  (if (> a c) (sum-of-squares b a)
      (sum-of-squares b c))
  )
)
              </code></pre>
            </div>
            After analyzing the code, I realized I was using 4 times the 
            <span class='answer-coded'>sum-of-squares</span> function.
            Therefore, it was too repetitive, and the intent of it was obscured
            by the nested <span class="answer-coded">if</span> statements. Here
            is a re-factoring that more clearly expresses the goal of the code.
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-scheme">
  (define (two_largest_numbers a b c)
  (if (> a b)
    (if (> b c) (list a b)
      (list a c)
    )  
    (if (> c a) (list b c)
        (list a b)
  )  
  ))
  (define (add_largest_sqrs a b c)
  (apply sum-of-squares (two_largest_numbers a b c)))
              </code></pre>
            </div>
          </div>
        </div>
      </li>
      <li>
        <p class="exercise"> Exercise 1.4: Observe that our model of evaluation 
          allows for combinations whose operators are <span class=
          'exercise-coded'>compound expressions</span>. Use this
          observation to describe the behavior of the following 
          <span class='exercise-coded'>procedure:</span>
          <div class="snippet-code">
            <div class="snippet-code-header">Scheme</div>
            <pre class="snippet-code-text"><code class="language-scheme">
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
            </code></pre>
          </div>
        </p>
        <div class="answer-block">
          <h2 class="answer-header">ANSWER</h2>
          <div class="answer-content">
            In order to analyze the behavior of: 
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-scheme">
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
              </code></pre>
            </div>
            Consider a simpler example: 
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-scheme">
(define (a-plus-b a b)
    (+ a b))
              </code></pre>
            </div>
            The <span class='answer-coded'>+</span> operation is clearly
            visible; the point of the exercise is to observe that in the 
            <span class='answer-coded'>a-plus-abs-b</span> procedure
            (a.k.a. function) the actual operation performed is not a simple 
            <span class="answer-coded">+</span> or <span class='answer-coded'>
            -</span>, but is something determined by the compound expresion
            <span class='answer-coded'>(if (> b 0) + -)</span>. 
          </div>
      </li>
      <li>
        <p class="exercise"> 
          Exercise 1.5: Ben Bitdiddle has invented a test to 
          determine whether the interpreter he is faced with is using
          <span class='exercise-coded'>applicative-order</span>
          evaluation or <span class='exercise-coded'>normal-order</span>
          evaluation. He defines the following two procedures:
          <div class="snippet-code">
            <div class="snippet-code-header">R5RS Scheme</div>
            <pre class="snippet-code-text"><code class="language-scheme">
(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y))
            </code></pre>
          </div>
        </p>
        <p class="exercise">
          Then he evaluates the expression:
          <div class="snippet-code">
            <div class="snippet-code-header">R5RS Scheme</div>
            <pre class="snippet-code-text"><code class="language-scheme">
(test 0 (p))
            </code></pre>
          </div>
        </p>
        <p class="exercise">
          What behavior will Ben observe with an interpreter that uses
          <span class='exercise-coded'>applicative-order</span> evaluation? What
          behavior will he observe with an interpreter that uses
          <span class='exercise-coded'>normal-order evaluation?</span> Explain
          your answer. (Assume that the evaluation rule for the special form 
          <span class='exercise-coded'>if</span> is the same whether the
          interpreter is using normal or applicative order: The predicate
          expression is evaluated first, and the result determines whether to
          evaluate the consequent or the alternative expression.)
        </p>
        <div class="answer-block">
          <h2 class="answer-header">ANSWER</h2>
          <div class="answer-content">
            In order to solve this exercise we analyze how the procedure would 
            be intrepreted using <span class='answer-coded'>
            normal-order evaluation</span><span style="font-weight: bold;">(note
            this just an interpretation of the steps of the normal-order
            evaluation for a real scheme program)</span>:
            <div class="snippet-code">
              <div class="snippet-code-header">normal-order evaluation</div>
              <pre class="snippet-code-text"><code class="language-scheme">
(test 0 (p))
  (if (= 0 0) 0 (p))
        0
              </code></pre>
            </div>
            <p>
              As we see in the example above, the <span class='answer-coded'>
              normal-order </span> evaluation doesn't care for the value of p.
              It just gives the answer of 0. However, let's now do the <span 
              class='answer-coded'>applicative-order</span> evaluation for this
              expresion.
            </p>
            <div class="snippet-code">
              <div class="snippet-code-header">applicative-order evaluation</div>
              <pre class="snippet-code-text"><code class="language-scheme">
(test 0 (p))
∞
              </code></pre>
            </div>
            <div style="display: flex; flex-direction: row;">
              <p>
                When running this command, it will cause an infinite loop. At
                the right is shown what it looks like at the bottom of the
                screen when I run the code using DrRacket.
              </p>
              <div class="img-container">
                DrRacket's bottom of the screen overview
                <img style="width:80%;" src="y.webp">
              </div>
          </div>
          </div>
        </div>
      </li>
      <li>
        <p class="exercise">
          Exercise 1.6: Alyssa P. Hacker doesn’t see why <span 
          class='exercise-coded'>if</span> needs to be provided as a 
          <span class='exercise-coded'>special form</span>. “Why can’t I just
          define it as an ordinary procedure in terms of <span 
          class='exercise-coded'>cond</span>?” she asks. Alyssa’s friend Eva Lu
          Ator claims this can indeed be done, and she defines a new version of
          if:
          <div class="snippet-code">
            <div class="snippet-code-header">Scheme</div>
            <pre class="snippet-code-text"><code class="language-scheme">
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
            </code></pre>
          </div>
        </p>
        <p class="exercise">
          Eva demonstrates the program for Alyssa:
        </p>
        <div class="snippet-code">
            <div class="snippet-code-header">Scheme (demonstration of the program)</div>
            <pre class="snippet-code-text"><code class="language-scheme">
(new-if (= 2 3) 0 5)
5
(new-if (= 1 1) 0 5)
0
            </code></pre>
          </div>
        <p class="exercise">
          Delighted, Alyssa uses <span class='exercise-coded'>new-if</span> to
          rewrite the square-root program:
        </p>
        <div class="snippet-code">
            <div class="snippet-code-header">Scheme</div>
            <pre class="snippet-code-text"><code class="language-scheme">
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
            </code></pre>
          </div>
        <p class="exercise">
          What happens when Alyssa attempts to use this to compute
          square roots? Explain.
        </p>
        <div class="answer-block">
          <h2 class="answer-header">ANSWER</h2>
          <div class="answer-content">
            This version of square root with the <span 
            class='answer-coded'>new-if</span> procedure instead of
            using the special form <span class='answer-coded'>if</span>, would
            still be as accurate as the first version. However, it is going to
            be slower, than the one that uses the directly the <span
            class='answer-coded'>if</span>, because a special form only analyze
            the alternative of the predicate, <span style="font-weight:
            bold;">if</span> only the predicate is <span class='answer-coded'>
            FALSE</span>. On the other hand a procedure will (no matter what)
            analyze all the operands, this resulting in a much slower program.
          </div>
          <!-- <img src="Newtons_Method.png"> -->
        </div>
      </li>
      <li>
        <p class="exercise">
          Exercise 1.7:
        </p>
        <ol>
          <li>
            <p class="exercise">
              Exercise 1.7.1: The <span class='exercise-coded'>
              good-enough?</span> test used in computing square roots will not
              be very eﬀective for finding the square roots of very small
              numbers. Also, in real computers, arith-metic operations are
              almost always performed with limited precision. This makes our
              test inadequate for very large numbers. Explain these statements,
              with examples showing how the test fails for small and large
              numbers.
            </p>
            <div class="answer-block">
              <h2 class="answer-header">ANSWER</h2>
              <div class="answer-content">
                <h3>
                  The good-enough? test is not effective for finding square
                  roots of very small numbers:
                </h3>
                <p style="padding-left: 10px; padding-right: 5px;">
                  This statement is the easy one to perceive at first glance.
                  The issue with the <span class='answer-coded'>
                  good-enough?</span> procedure is that it compares the absolute
                  difference of the guess, and the x value, against a specific
                  quantity such as <span class='answer-coded'>0.001</span>.
                  Thus, when it receives as input a number that is smaller than
                  that quantity, at a certain point the guess will be enough to
                  satisfy the condition when the arithmetic is done in the <span
                  class='answer-coded'>good-enough?</span> procedure. However,
                  it will be far away to the real square root. For example,
                  let's take the number <span class=
                  'answer-coded'>0.000000000009</span>. The real square root of
                  this number is <span class='answer-coded'>0.000003</span>, but
                  this square-root program returns the value of <span
                  class='answer-coded'>0.03125000009590625</span>. What ended up
                  happening, is that the <span class='code'>improve</span>
                  procedure started to give the following numbers as the guess
                  through every iteration: 0.5000000000045, 0.25000000001125,
                  0.125000000023625, 0.06250000004781249, and the last,
                  0.03125000009590625. Now, why is this the last? It is because
                  of the following calculation in the <span class='
                  answer-coded'>good-enough?</span> procedure: 
                  <span class='answer-coded'>
                  (< (abs (- (square guess) x)) 0.001)</span>. Therefore, this
                  occur:
                  </p>
                  <div class="snippet-code">
                    <div class="snippet-code-header">normal-order
                      evaluation</div>
                    <pre class="snippet-code-text"><code class="language-scheme">
(< (abs (- (square 0.03125000009590625) 0.000000000009)) 0.001)
(< (abs (- (* 0.03125000009590625 0.03125000009590625) 0.000000000009)) 0.001)
(< (abs (- 0.0009765625059941405 0.000000000009)) 0.001)
#t
                    </code></pre>
                  </div>
                  <p style="padding-left: 10px; padding-right: 5px;">
                    Which the result is true, thus the number <span
                    class='answer-coded'>03125000009590625</span> according to
                    this algorithm is the square root of 0.000000000009.
                    Nonetheless, as mentioned before the real square root is
                    <span class='answer-coded'>0.000003</span>. This example
                    crearly shows the fauls of this algorithm for really small
                    numbers, but in a more clear way to say it, this algorithm
                    will not work for numbers that are smallers than the fixed
                    number in the <span class="answer-coded">good-enough?</span>
                    procedure.
                  </p>
                <h3>
                  In real computers arithmetics operations are almost always
                  performed with limited precision, making the test poor for
                  calculating large numbers.
                </h3>
                <p style="padding-left: 10px; padding-right: 5px;">
                  This problem is related to floating-point precision. As 
                  mentioned before, in computers huge numbers are not affected
                  by smaller numbers at a certain distance. Consider this
                  example, try this in your browser console:
                </p>
                <div class="snippet-code">
                  <div class="snippet-code-header">javascript</div>
                  <pre class="snippet-code-text"><code 
                    class="language-javascript">
let googol = 1e100
googol == googol + 1
                  </code></pre>
                </div> 
                <div style="display: flex; flex-direction: column; padding-left: 10px; padding-right: 5px;">
                  <p>
                    This should return something like this:
                  </p>
                  <img style="width: 30%; border-radius: 8px;" src="./googol_example.png"
alt="example_of_floating_point_precision_from_the_console">
                  <p>
                    So, according to that, we can now state that floating-point
                    numbers deals arithmetics with their own rules. Another
                    example could be with the number <span class="answer-coded">
                    1e49</span>. If we do the following code in <span 
                    class='answer-coded'>javascript</span>:
                  </p>
                    <div class="snippet-code">
                      <div class="snippet-code-header">javascript</div>
                      <pre class="snippet-code-text"><code 
                        class="language-javascript">
let exactSqrt = Math.sqrt(1e49) // this returns 3.162277660168379e+24
exactSqrt * exactSqrt // the value returned is 9.999999999999998e+48
                      </code></pre>
                    </div>
                    <p>
                      This is important to understand better floating-point
                      precision. As we can notice, the square root of <span
                      class='answer-coded'>1e49</span> is 3.162277660168379e+24;
                      however, this number squared does not give the exact same
                      value, as if we were working with a small number. This leads
                      us to the <span class='answer-coded'>good-enough?</span>
                      procedure. Same as the last time, lets analyze this example.
                      Supose that we iterate until we get this number <span
                      class='answer-coded'>3.162308428500741e+24</span> as our
                      guess. What will happen next is something like this:
                    </p>
                    <div class="snippet-code">
                      <div class="snippet-code-header">normal-order
                        evaluation</div>
                      <pre class="snippet-code-text"><code 
                        class="language-scheme">
(< (abs (- (square guess) x)) 0.001)
(< (abs (- (square 3.162308428500741e+24) 1e49)) 0.001)
(< (abs (- (* 3.162308428500741e+24 3.162308428500741e+24) 1e49)) 0.001)
(< (abs (- 1.0000194596966827e+49 1e49)) 0.001)
#f
                      </code></pre>
                    </div>
                    <p>
                      Why does it return false? Although the numbers looks
                      really close, they are actually not. They are different
                      for a large chain of numbers. We have to remember that
                      these are floating-point numbers, and they represent a
                      large sequence of numbers not just the ones that are
                      written down. Therefore, what will happen after it, is
                      that procedures like <span 
                      class="answer-coded">improve</span> and <span
                      class='answer-coded'>average</span>, they are really not
                      going to change the number at all anymore, because of
                      floating-point arithmetic. This ending in an infinite loop
                      or in an infinite call of functions, what will exceed at
                      some point the maximun call stack.
                    </p>
                  </p>
                </div>
              </div>
            </div>
          </li>
          <li>
            <p class="exercise">
              Exercise 1.7.2: An alternative strategy for implementing
              good-enough? is to watch how guess changes from one iteration to 
              the next and to stop when the change is a very small fraction of 
              the guess. Design a square-root procedure that uses this kind of
              end test. Does this work better for small and large numbers?
            </p>
            <div class="answer-block">
              <h2 class="answer-header">ANSWER</h2>
              <div class="answer-content">
                In order to make this change, the only part of the code that has
                to be modified is the <span class='answer-coded'>
                good-enough?</span> procedure to make it execute a relative
                difference with the <span class='answer-coded'>old-guess</span>,
                and the <span class='answer-coded'>current-guess</span>. Also,
                the <span class='answer-coded'>if</span> is going to do <span
                class='answer-coded'>good-enough?</span> of the <span 
                class="answer-coded">guess</span>, and the improved
                <span class="answer-coded">guess</span>:
                <div class="snippet-code">
                  <div class="snippet-code-header">Scheme</div>
                  <pre class="snippet-code-text"><code class="language-scheme">
(define (good-enough? old-guess current-guess)
  (< (/ (abs (- current-guess old-guess)) old-guess) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess (improve guess x))
      guess
      (sqrt-iter (improve guess x) x)))
                  </code></pre>
                </div>
                The full code would look like this:
                <div class="snippet-code">
                  <div class="snippet-code-header">Scheme</div>
                  <pre class="snippet-code-text"><code class="language-scheme">
(define (sqrt-iter guess x)
  (if (good-enough? guess (improve guess x))
      guess
      (sqrt-iter (improve guess x) x)))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (good-enough? old-guess current-guess)
  (< (/ (abs (- current-guess old-guess)) old-guess) 0.001))

(define (square-root x)
  (sqrt-iter 1.0 x))
                  </code></pre>
                </div>
              </div>
            </div>
          </li>
        </ol>
      </li>
      <li>
        <p class="exercise">
          Exercise 1.8: Newton’s method for cube roots is based on the fact that
          if <span class='exercise-coded'>y</span> is an approximation to the
          cube root of <span class='exercise-coded'>x</span>, then a better
          approximation is given by the value:
        </p>
          <div class="exercise">
            <math display="block">
              <mfrac>
                <mrow>
                  <mrow>
                    <mi>x</mi>
                    <mo>/</mo>
                    <msup>
                      <mi>y</mi><mn>2</mn>
                    </msup>
                  </mrow>
                  <mo>+</mo>
                  <mrow>
                    <mn>2</mn><mi>y</mi>
                  </mrow>
                </mrow>
                <mn>3</mn>
              </mfrac>
            </math>
          </div>
        <p class="exercise">
          Use this formula to implement a cube-root procedure analogous to
          the square-root procedure.
        </p>
        <div class="answer-block">
          <h3 class="answer-header">ANSWER</h3>
          <div class="answer-content">
            For the creation of this code first of all we have to understand
            what the exercise is telling. Through the analysis of the
            indication, we can state the following conclusion: <span
            class="answer-coded">y</span> is our <span class='answer-coded'>
            guess</span> since the indications are: based on the fact that
            <span class='answer-coded'>y</span> is an approximation of the
            cube root for <span class="answer-coded">x</span> with the
            shown formula we get a better approximation. Therefore like we
            can say <span class="answer-coded">guess == y</span>.
            Now that we are concious of that, we can create a function that
            serves as the use of the formula:
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(define (approximate y x)
(/ (+ (/ x (* y y)) (* 2 y)) 3))
              </code></pre>
            </div>
            Afterwards, we can now call our <span class="answer-coded">
            approximate</span> function (procedure) and as we mentioned,
            <span class='answer-coded'>guess</span> in this case will be
            used as the second parameter of that function, the <span
            class='answer-coded'>y</span>. So we can just replicate the
            logic for the <span class='answer-coded'>square-root</span>
            function, but in this case, replacing <span 
            class="answer-coded">improve</span> for <span 
            class="answer-coded">approximate</span>. So the final program
            looks like this:
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(define (cube-root-iter guess x)
(if (good-enough? guess (approximate guess x))
  guess
  (cube-root-iter (approximate guess x) x)))

(define (cube-root x)
(cbrt-iter 1.0 x))
              </code></pre>
            </div>                
          </div>
        </div>
      </li>
      <li>
        <p class="exercise">
          Exercise 1.9: Each of the following two procedures defines a method
          for adding two positive integers in terms of the procedures <span
          class='exercise-coded'>inc</span>, which increments its argument by 1,
          and <span class='exercise-coded'>dec</span>, which decrements its
          argument by 1.
        </p>
        <div class="snippet-code">
          <div class="snippet-code-header">Scheme</div>
          <pre class="snippet-code-text"><code class="language-scheme">
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
          </code></pre>
        </div>
        <div class="answer-block">
          <h3 class="answer-header">ANSWER</h3>
          <div class="answer-content">
          <h3>
            First procedure example
          </h3>
          <p style="padding-left: 10px; padding-right: 5px;">
            For the first procedure, we can see the shape of the process using
            the substitution model:
          </p>
            <div class="snippet-code">
              <div class="snippet-code-header">normal-order evaluation</div>
              <pre class="snippet-code-text"><code class="language-scheme">
(+ 4 5)
(inc (+ (dec 4) 5))
(inc (+ 3 5))
(inc (inc (+ (dec 3) 5)))
(inc (inc (+ 2 5)))
(inc (inc inc (+ (dec 2) 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ (dec 1) 5))))) 
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
              </code></pre>
            </div>
            <p style="padding-left: 10px; padding-right: 5px;">
              We can notice now, with the illustration above that this is 
              procedure example is a recursive process. First of all because the
              shape of it grows until it meets the condition, and then it starts
              shrinking until we get the result.
            </p>
            <h3>Second procedure example</h3>
            <p style="padding-left: 10px; padding-right: 5px;">
              For the second procedure we notice that the shape is not the same:
            </p>
            <div class="snippet-code">
              <div class="snippet-code-header">normal-order evaluation</div>
              <pre class="snippet-code-text"><code class="language-scheme">
(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9
              </code></pre>
            </div>
            <p style="padding-left: 10px; padding-right: 5px;">
              And as the shape changes, that indicates the process is 
              different too; it is iterative. However, there are another few
              reasons why the process is iterative besides the shape. We can
              notice a big difference between the recursive one (the first 
              example), and this one (iterative). Let's elaborate:
            </p>
            <p style="padding-left: 10px; padding-right: 5px;">
              The recursive process as
              mentioned before, needs to keep track of all the values every
              state. We can think of it like this, if you would want to execute
              one of the state individually for the recursive example, say <span 
              class='answer-coded'>(inc (inc (+ 2 5)))</span> in the
              <span class='answer-coded'>interpreter</span>. Because of the way
              a recursive process is meant to be written, no matter if I want to
              execute a single calculation within the process itself; unless the
              parameters meet the stoping condition, it will always end up
              calling itself recursively, and therefore looking like the first
              illustration (recursive process) until the condition make it stop.
              On the other hand, in the iterative process, there is always track
              of the every value. Thus, every state can be performed as
              individual computation. If we choose a random state for the
              iterative procedure like: <span class='answer-coded'>
              (+ (dec 2) (inc 7))</span> as an example. This can be done in the
              interpreter without any recursion, and that is another main
              difference between recursive and iterative procedures.
              Additionally, to understand better how the iterative procedure
              differs from the recursive; in this procedure the number at the
              left (The one that is decrementing), works as a counter. Each time
              this "counter" decrement by one, the number at the right is going
              to increment by one. Unlike the recursive one, each state contains 
              its own fixed value, and the number of iteration is determined by
              counter.
            </p>
          </div>
        </div>
      </li>
      <li>
        <p class="exercise">
          Exercise 1.10: The following procedure computes a mathematical
          function called Ackermann’s function.
        </p>
        <div class="snippet-code">
          <div class="snippet-code-header">Scheme</div>
          <pre class="snippet-code-text"><code class="language-lisp">
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
          </code></pre>
        </div>
        <p class="exercise">
          What are the values of the following expressions?
        </p>
        <div class="snippet-code">
          <div class="snippet-code-header">Scheme</div>
          <pre class="snippet-code-text"><code class="language-lisp">
(A 1 10)
(A 2 4)
(A 3 3)
          </code></pre>
        </div>
        <p class="exercise">
          Consider the following procedures, where A is the procedure defined
          above:
        </p>
        <div class="snippet-code">
          <div class="snippet-code-header">Scheme</div>
          <pre class="snippet-code-text"><code class="language-lisp">
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
          </code></pre>
        </div>
        <p class="exercise">
          Give concise mathematical definitions for the functions computed by
          the procedures f, g, and h for positive integer values of n. For
          example, (k n) computes 5n<sup>2</sup>.
        </p>
        <div class="answer-block">
          <h3 class="answer-header">ANSWER</h3>
          <div class="answer-content">
            <div class="snippet-code">
              <div class="snippet-code-header">normal-order evaluation</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024
              </code></pre>
            </div>
            <div class="snippet-code">
              <div class="snippet-code-header">normal-order evaluation</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
(A 0 (A 1 15))
(A 0 (A 0 (A 1 14)))
(A 0 (A 0 (A 0 (A 1 13))))
(A 0 (A 0 (A 0 (A 0 (A 1 12)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 9))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 8)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 7))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 6)))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 32)))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 64))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 128)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 256))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 512)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))
(A 0 (A 0 (A 0 (A 0 (A 0 2048)))))
(A 0 (A 0 (A 0 (A 0 4096))))
(A 0 (A 0 (A 0 8192)))
(A 0 (A 0 16384))
(A 0 32768)
65536
              </code></pre>
            </div>
            <div class="snippet-code">
              <div class="snippet-code-header">normal-order evaluation</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
.
.
.
65536

              </code></pre>
            </div>
            <p>
              A concise mathematical definition for <span 
              class='answer-coded'>f</span> is: <span class='answer-coded'>
               (f n)</span> computes <span class="answer-coded">2n
              </span>
            </p>
            <p>
              A concise mathematical definition for <span 
              class='answer-coded'>g</span> is: <span class='answer-coded'>
               (g n)</span> computes <span class="answer-coded">2<sup>n</sup>
              </span>
            </p>
            <p>
              A concise mathematical definition for <span 
              class='answer-coded'>h</span> is: <span class='answer-coded'>
               (h n)</span> computes <span class="answer-coded"><sup>n</sup>2</span> aka <span class='answer-coded'>2↑↑n</span> (tetration)
            </p>
            <p>
              By the way, I observe that the above definition of the Ackerman
              function differs from the traditional definition, which in R5RS
              would look like this:
            </p>
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(define (ackermann m n)
  (cond ((= m 0) (+ n 1))
        ((= n 0) (ackermann (- m 1) 1))
        (else (ackermann (- m 1) (ackermann m (- n 1))))))
              </code></pre>
            </div>
          </div>
        </div>
      </li>
      <li>
        <p class="exercise">
          Exercise 1.11: A function f is defined by the rule that
          \[f(n) = 
          \begin{cases} 
          \phantom{f(n - 1) + f(n } n & \text{if } n < 3 \\
          f(n - 1) + f(n - 2) + f(n - 3) & \text{if } n \geq 3
          \end{cases}\]
          Write a procedure that computes \(f\) by means of a recursive process.
          Write a procedure that computes \(f\) by means of an iterative
          process.
        </p>
        <div class="answer-block">
          <h3 class="answer-header">ANSWER</h3>
          <div class="answer-content">
            <h3>Recursive procedure example</h3>
            <div class="snippet-code">
              <div class="snippet-code-header">Scheme</div>
              <pre class="snippet-code-text"><code class="language-lisp">
(define (recursive-pascal-triangle n)
    (if (< n 3)
        n
        (+ (pascal-triangle (- n 1)) 
           (* 2 (pascal-triangle (- n 2)))
           (* 3 (pascal-triangle (-n 3))))))
              </code></pre>
            </div>
            <h3>Iterative procedure example</h3>
            Working on it...
          </div>
        </div>
      </li>
    </ol>
  </div>
  <script>
    Prism.languages.scheme = Prism.languages.extend('lisp', {
      keyword: /\b(?:define|lambda|if|cond|else|let|letrec|begin|quote|set!|and|or|not|car|cdr|cons|list|map|apply|eq\?|equal\?|null\?|display|newline|call\/cc)\b/,
      builtin: {
        // note: no native lookbehind, use Prism's flag
        pattern: /(^|[()\s])(?:\+|\-|\*|\/|=|<=|>=|<|>)(?=[()\s]|$)/,
        lookbehind: true,
        greedy: true
      },
      boolean: /#t|#f/,
      number: /\b\d+(?:\.\d+)?\b/
    });

    // ensure builtins come before punctuation
    Prism.languages.insertBefore('scheme', 'punctuation', {
      operator: Prism.languages.scheme.builtin
    });

    Prism.highlightAll();
  </script>
</body>